## model structures
kstructures <- model_structure(kfa, which = "cfa")
## loadings
klambdas <- agg_loadings(kfa, flag = load.flag, digits = digits)
## factor correlations
kcorrs <- agg_cors(kfa, flag = cor.flag)
## score reliabilities
krels <- agg_rels(kfa, flag = rel.flag, digits = digits)
kfa$cfa.syntax
## organize output by folds
kfits <- vector("list", length = k)
for(f in 1:k){
fits.df <- cbind(data.frame(model = model.names[[f]]),
as.data.frame(Reduce(rbind, fits[[f]])))
row.names(fits.df) <- NULL
kfits[[f]] <- fits.df
}
model.names <- lapply(mods$cfas, names) # list with unique set of names for each fold
model.names
## extract fit for every model in each fold
fits <- vector("list", length = k)
for(f in 1:k){
fits[[f]] <- lapply(mods$cfas[[f]], function(x) {
if(lavaan::lavInspect(x, "converged")){
lavaan::fitmeasures(x, index)
}
})
}
fits
model.names <- lapply(mods$cfas, names) # list with unique set of names for each fold
index <- if(sum(grepl("df", index)) == 0) c("df", index) else index
## organize output by folds
kfits <- vector("list", length = k)
for(f in 1:k){
fits.df <- cbind(data.frame(model = model.names[[f]]),
as.data.frame(Reduce(rbind, fits[[f]])))
row.names(fits.df) <- NULL
kfits[[f]] <- fits.df
}
kfits
## extract fit for every model in each fold
fits <- vector("list", length = k)
for(f in 1:k){
fits[[f]] <- lapply(mods$cfas[[f]], function(x) {
if(lavaan::lavInspect(x, "converged")){  # can only extract fit from models that converged
lavaan::fitmeasures(x, index)
}
})
fits[[f]] <- fits[[f]][lengths(fits[[f]]) != 0] # dropping NULL elements (models that did not converge)
}
fits
fits[[4]][[1]]
fits[[4]][[4]]
## organize output by folds
kfits <- vector("list", length = k)
for(f in 1:k){
fits.df <- cbind(data.frame(model = model.names[[f]]),
as.data.frame(Reduce(rbind, fits[[f]])))
row.names(fits.df) <- NULL
kfits[[f]] <- fits.df
}
kfits
lapply(fits, names)
## extract fit for every model in each fold
fits <- vector("list", length = k)
for(f in 1:k){
fits[[f]] <- lapply(mods$cfas[[f]], function(x) {
if(lavaan::lavInspect(x, "converged")){  # can only extract fit from models that converged
lavaan::fitmeasures(x, index)
}
})
fits[[f]] <- fits[[f]][lengths(fits[[f]]) != 0] # dropping NULL elements (models that did not converge)
}
model.names <- lapply(fits, names) # list with unique set of names for each fold
## organize output by folds
kfits <- vector("list", length = k)
for(f in 1:k){
fits.df <- cbind(data.frame(model = model.names[[f]]),
as.data.frame(Reduce(rbind, fits[[f]])))
row.names(fits.df) <- NULL
kfits[[f]] <- fits.df
}
example <- kfa(variables = sim.boxes,
k = NULL) # prompts power analysis to determine number of folds
kfa <- example
index = c("chisq", "cfi", "rmsea")
load.flag = .30
cor.flag = .90
rel.flag = .60
digits = 2
## analysis summary info
k <- length(kfa$cfas) # number of folds
## analysis summary info
k <- length(kfa$cfas) # number of folds
m <- max(unlist(lapply(kfa$cfas, length))) # number of models per fold (includes both efa AND custom structures); m == length(mnames)
mnames <- unique(unlist(lapply(kfa$cfas, names))) # model names
fac.allow <- length(kfa$efa.structures)
fac.max <- max(as.numeric(substring(mnames[grepl("-factor", mnames)], 1, 1)))  # kfa naming convention "#-factor"; custom functions are assumed to have different convention
vnames <- dimnames(lavaan::lavInspect(kfa$cfas[[1]][[1]], "sampstat")$cov)[[1]] # variable names
nvars <- length(vnames)
nobs <- sum(unlist(lapply(kfa$cfas, function(x) lavaan::lavInspect(x[[1]], "nobs"))))
opts <- lavaan::lavInspect(kfa$cfas[[1]][[1]], "options") # estimation options; assumed to be the same for all models
#### Model Fit ####
## summarizing fit statistics by fold
kfits <- k_model_fit(kfa, index = index, by.fold = TRUE) # dataframe for each fold
index <- if(sum(grepl("df", index)) == 0) c("df", index) else index
## extract fit for every model in each fold
fits <- vector("list", length = k)
for(f in 1:k){
fits[[f]] <- lapply(example$cfas[[f]], function(x) {
if(lavaan::lavInspect(x, "converged")){  # can only extract fit from models that converged
lavaan::fitmeasures(x, index)
}
})
fits[[f]] <- fits[[f]][lengths(fits[[f]]) != 0] # dropping NULL elements (models that did not converge)
}
model.names <- lapply(fits, names) # list with unique set of names for each fold
## organize output by folds
kfits <- vector("list", length = k)
for(f in 1:k){
fits.df <- cbind(data.frame(model = model.names[[f]]),
as.data.frame(Reduce(rbind, fits[[f]])))
row.names(fits.df) <- NULL
kfits[[f]] <- fits.df
}
## organize output by model
if(by.fold == FALSE){
for(i in 1:length(kfits)){ # Add column for fold
kfits[[i]] <- cbind(fold = i, kfits[[i]])
}
mfits <- Reduce(rbind, kfits) # bind folds into single dataframe
# create separate list for each unique model
mods <- unique(mfits$model)
kfits <- vector("list", length(mods))
for(i in 1:length(mods)){
temp <- mfits[mfits$model == mods[[i]],]
temp$model <- NULL
kfits[[i]] <- temp
}
names(kfits) <- mods
}
by.fold = TRUE
## organize output by model
if(by.fold == FALSE){
for(i in 1:length(kfits)){ # Add column for fold
kfits[[i]] <- cbind(fold = i, kfits[[i]])
}
mfits <- Reduce(rbind, kfits) # bind folds into single dataframe
# create separate list for each unique model
mods <- unique(mfits$model)
kfits <- vector("list", length(mods))
for(i in 1:length(mods)){
temp <- mfits[mfits$model == mods[[i]],]
temp$model <- NULL
kfits[[i]] <- temp
}
names(kfits) <- mods
}
kfits
library(kfa)
kfa <- example
index = c("chisq", "cfi", "rmsea")
load.flag = .30
cor.flag = .90
rel.flag = .60
digits = 2
#### Model Fit ####
## summarizing fit statistics by fold
kfits <- k_model_fit(kfa, index = index, by.fold = TRUE) # dataframe for each fold
library(kfa)
library(kfa)
#### Model Fit ####
## summarizing fit statistics by fold
kfits <- k_model_fit(kfa, index = index, by.fold = TRUE) # dataframe for each fold
kfits
fit.table <- agg_model_fit(kfits, index = index, digits = 2)
fit.table
## model structures
kstructures <- model_structure(kfa, which = "cfa")
## loadings
klambdas <- agg_loadings(kfa, flag = load.flag, digits = digits)
## factor correlations
kcorrs <- agg_cors(kfa, flag = cor.flag)
## score reliabilities
krels <- agg_rels(kfa, flag = rel.flag, digits = digits)
## flagged problems
flagged <- model_flags(kfa, kstructures, klambdas, kcorrs, krels)
cfas <- example$cfas
mnames <- unique(unlist(lapply(cfas, names))) # model names
kcorrs <- vector("list", m)
kflag <- vector("integer", m)
# Currently assumes the first element is a 1 factor model; need a more robust check
kcorrs[[1]] <- NULL
kflag[[1]] <- NA
for(n in 2:m){
cor.lv <- vector("list", k) # latent variable correlation matrix
cor.flag <- vector("list", k) # count of correlations above flag threshold
for(f in 1:k){
if(mnames[[n]] %in% names(cfas[[f]])){
cor.lv[[f]] <- lavaan::lavInspect(cfas[[f]][[mnames[[n]]]], "cor.lv")
cor.flag[[f]] <- rowSums(cor.lv[[f]] > flag) - 1 # minus diagonal which will always be TRUE
}
}
## count of folds with a correlation over flag threshold
fc <- unlist(cor.flag)
cflag <- tapply(fc, names(fc), function(x) sum(x > 0)) # for each factor
kflag[[n]] <- sum(unlist(lapply(cor.flag, sum)) > 0)      # for the model
## mean correlation across folds
cor.lv <- cor.lv[lengths(cor.lv) != 0] # removes NULL elements for folds were model was not run
aggcorrs <- Reduce(`+`, cor.lv) / length(cor.lv)
aggcorrs[upper.tri(aggcorrs, diag = FALSE)] <- NA
aggcorrs <- cbind(data.frame(rn = row.names(aggcorrs)),
aggcorrs, data.frame(flag = cflag))
kcorrs[[n]] <- aggcorrs
}
flag <- cor.flag
kcorrs <- vector("list", m)
kflag <- vector("integer", m)
# Currently assumes the first element is a 1 factor model; need a more robust check
kcorrs[[1]] <- NULL
kflag[[1]] <- NA
for(n in 2:m){
cor.lv <- vector("list", k) # latent variable correlation matrix
cor.flag <- vector("list", k) # count of correlations above flag threshold
for(f in 1:k){
if(mnames[[n]] %in% names(cfas[[f]])){
cor.lv[[f]] <- lavaan::lavInspect(cfas[[f]][[mnames[[n]]]], "cor.lv")
cor.flag[[f]] <- rowSums(cor.lv[[f]] > flag) - 1 # minus diagonal which will always be TRUE
}
}
## count of folds with a correlation over flag threshold
fc <- unlist(cor.flag)
cflag <- tapply(fc, names(fc), function(x) sum(x > 0)) # for each factor
kflag[[n]] <- sum(unlist(lapply(cor.flag, sum)) > 0)      # for the model
## mean correlation across folds
cor.lv <- cor.lv[lengths(cor.lv) != 0] # removes NULL elements for folds were model was not run
aggcorrs <- Reduce(`+`, cor.lv) / length(cor.lv)
aggcorrs[upper.tri(aggcorrs, diag = FALSE)] <- NA
aggcorrs <- cbind(data.frame(rn = row.names(aggcorrs)),
aggcorrs, data.frame(flag = cflag))
kcorrs[[n]] <- aggcorrs
}
mnames[[2]]
names(cfas[[2]])
cor.lv
cor.flag
cor.lv[[f]]
cor.lv[[f]] > flag
cor.lv[[1]] > flag
cor.lv[[1]]
names(cfas[[1]])
m
class(cor.lv[[1]])
cor.lv[[1]] >.90
flag
flag <- .90
kcorrs <- vector("list", m)
kflag <- vector("integer", m)
# Currently assumes the first element is a 1 factor model; need a more robust check
kcorrs[[1]] <- NULL
kflag[[1]] <- NA
for(n in 2:m){
cor.lv <- vector("list", k) # latent variable correlation matrix
cor.flag <- vector("list", k) # count of correlations above flag threshold
for(f in 1:k){
if(mnames[[n]] %in% names(cfas[[f]])){
cor.lv[[f]] <- lavaan::lavInspect(cfas[[f]][[mnames[[n]]]], "cor.lv")
cor.flag[[f]] <- rowSums(cor.lv[[f]] > flag) - 1 # minus diagonal which will always be TRUE
}
}
## count of folds with a correlation over flag threshold
fc <- unlist(cor.flag)
cflag <- tapply(fc, names(fc), function(x) sum(x > 0)) # for each factor
kflag[[n]] <- sum(unlist(lapply(cor.flag, sum)) > 0)      # for the model
## mean correlation across folds
cor.lv <- cor.lv[lengths(cor.lv) != 0] # removes NULL elements for folds were model was not run
aggcorrs <- Reduce(`+`, cor.lv) / length(cor.lv)
aggcorrs[upper.tri(aggcorrs, diag = FALSE)] <- NA
aggcorrs <- cbind(data.frame(rn = row.names(aggcorrs)),
aggcorrs, data.frame(flag = cflag))
kcorrs[[n]] <- aggcorrs
}
## count of folds with a correlation over flag threshold
fc <- unlist(cor.flag)
cflag <- tapply(fc, names(fc), function(x) sum(x > 0)) # for each factor
kflag[[n]] <- sum(unlist(lapply(cor.flag, sum)) > 0)      # for the model
## mean correlation across folds
cor.lv <- cor.lv[lengths(cor.lv) != 0] # removes NULL elements for folds were model was not run
aggcorrs <- Reduce(`+`, cor.lv) / length(cor.lv)
aggcorrs[upper.tri(aggcorrs, diag = FALSE)] <- NA
aggcorrs <- cbind(data.frame(rn = row.names(aggcorrs)),
aggcorrs, data.frame(flag = cflag))
kcorrs[[n]] <- aggcorrs
## factor correlations
kcorrs <- agg_cors(kfa, flag = cor.flag)
cor.lv
n
f
kcorrs <- vector("list", m)
kflag <- vector("integer", m)
# Currently assumes the first element is a 1 factor model; need a more robust check
kcorrs[[1]] <- NULL
kflag[[1]] <- NA
n <- 2
cor.lv <- vector("list", k) # latent variable correlation matrix
cor.flag <- vector("list", k) # count of correlations above flag threshold
for(f in 1:k){
if(mnames[[n]] %in% names(cfas[[f]])){
cor.lv[[f]] <- lavaan::lavInspect(cfas[[f]][[mnames[[n]]]], "cor.lv")
cor.flag[[f]] <- rowSums(cor.lv[[f]] > flag) - 1 # minus diagonal which will always be TRUE
}
}
## count of folds with a correlation over flag threshold
fc <- unlist(cor.flag)
cflag <- tapply(fc, names(fc), function(x) sum(x > 0)) # for each factor
kflag[[n]] <- sum(unlist(lapply(cor.flag, sum)) > 0)      # for the model
## mean correlation across folds
cor.lv <- cor.lv[lengths(cor.lv) != 0] # removes NULL elements for folds were model was not run
aggcorrs <- Reduce(`+`, cor.lv) / length(cor.lv)
aggcorrs[upper.tri(aggcorrs, diag = FALSE)] <- NA
aggcorrs <- cbind(data.frame(rn = row.names(aggcorrs)),
aggcorrs, data.frame(flag = cflag))
kcorrs[[n]] <- aggcorrs
n <- 3
cor.lv <- vector("list", k) # latent variable correlation matrix
cor.flag <- vector("list", k) # count of correlations above flag threshold
for(f in 1:k){
if(mnames[[n]] %in% names(cfas[[f]])){
cor.lv[[f]] <- lavaan::lavInspect(cfas[[f]][[mnames[[n]]]], "cor.lv")
cor.flag[[f]] <- rowSums(cor.lv[[f]] > flag) - 1 # minus diagonal which will always be TRUE
}
}
## count of folds with a correlation over flag threshold
fc <- unlist(cor.flag)
cflag <- tapply(fc, names(fc), function(x) sum(x > 0)) # for each factor
kflag[[n]] <- sum(unlist(lapply(cor.flag, sum)) > 0)      # for the model
## mean correlation across folds
cor.lv <- cor.lv[lengths(cor.lv) != 0] # removes NULL elements for folds were model was not run
aggcorrs <- Reduce(`+`, cor.lv) / length(cor.lv)
aggcorrs[upper.tri(aggcorrs, diag = FALSE)] <- NA
aggcorrs <- cbind(data.frame(rn = row.names(aggcorrs)),
aggcorrs, data.frame(flag = cflag))
kcorrs[[n]] <- aggcorrs
n <- 4
kcorrs
cor.lv <- vector("list", k) # latent variable correlation matrix
cor.flag <- vector("list", k) # count of correlations above flag threshold
for(f in 1:k){
if(mnames[[n]] %in% names(cfas[[f]])){
cor.lv[[f]] <- lavaan::lavInspect(cfas[[f]][[mnames[[n]]]], "cor.lv")
cor.flag[[f]] <- rowSums(cor.lv[[f]] > flag) - 1 # minus diagonal which will always be TRUE
}
}
## count of folds with a correlation over flag threshold
fc <- unlist(cor.flag)
cflag <- tapply(fc, names(fc), function(x) sum(x > 0)) # for each factor
kflag[[n]] <- sum(unlist(lapply(cor.flag, sum)) > 0)      # for the model
## mean correlation across folds
cor.lv <- cor.lv[lengths(cor.lv) != 0] # removes NULL elements for folds were model was not run
aggcorrs <- Reduce(`+`, cor.lv) / length(cor.lv)
aggcorrs[upper.tri(aggcorrs, diag = FALSE)] <- NA
aggcorrs <- cbind(data.frame(rn = row.names(aggcorrs)),
aggcorrs, data.frame(flag = cflag))
kcorrs[[n]] <- aggcorrs
kcorrs
kflag
names(kcorrs) <- mnames
names(kflag) <- mnames
example$cfa.syntax
klambdas
names(example$cfas)
lapply(example$cfas, names)
data("AmzBoxes")
BoxList <- GenerateBoxData (XYZ = AmzBoxes[,2:4],
BoxStudy = 20,
Reliability = .75,
ModApproxErrVar = .10,
SampleSize = 900,
NMinorFac = 50,
epsTKL = .20,
Seed = 1161,
SeedErrorFactors = 1611,
SeedMinorFactors = 6111,
PRINT = FALSE,
LB = FALSE,
LBVal = 1,
Constant = 0)
sim.boxes <- BoxList$BoxDataEME
example <- kfa(variables = sim.boxes,
k = NULL) # prompts power analysis to determine number of folds
kfa <- example
index = c("chisq", "cfi", "rmsea")
load.flag = .30
cor.flag = .90
rel.flag = .60
digits = 2
by.fold = TRUE
kfa <- kfa$cfas
k <- length(kfa) # number of folds
m <- max(unlist(lapply(kfa, length))) # number of models per fold
index <- if(sum(grepl("df", index)) == 0) c("df", index) else index
## extract fit for every model in each fold
fits <- vector("list", length = k)
for(f in 1:k){
fits[[f]] <- lapply(kfa[[f]], function(x) {
if(lavaan::lavInspect(x, "converged")){  # can only extract fit from models that converged
lavaan::fitmeasures(x, index)
}
})
fits[[f]] <- fits[[f]][lengths(fits[[f]]) != 0] # dropping NULL elements (models that did not converge)
}
fits
model.names <- lapply(fits, names) # list with unique set of names for each fold
## organize output by folds
kfits <- vector("list", length = k)
for(f in 1:k){
fits.df <- cbind(data.frame(model = model.names[[f]]),
as.data.frame(Reduce(rbind, fits[[f]])))
row.names(fits.df) <- NULL
kfits[[f]] <- fits.df
}
kfits
index <- index[index != "df"] # df is added automatically so don't need to loop through it
bdf <- Reduce(rbind, kfits)
bdf
mnames <- unique(bdf$model)
mnames
tapply(bdf[["df"]], bdf$model, mean)
as.data.frame(tapply(bdf[["df"]], bdf$model, mean))
tempas.data.frame(tapply(bdf[["df"]], bdf$model, mean))
temp <- as.data.frame(tapply(bdf[["df"]], bdf$model, mean))
?as.data.frame
degf <- tapply(bdf[["df"]], bdf$model, mean)
fit <- data.frame(model = names(degf),
df = degf)
fit
i <- index[[1]]
i
tapply(bdf[[i]], bdf$model, mean)
bdf <- Reduce(rbind, kfits)
# mnames <- unique(bdf$model)
degf <- tapply(bdf[["df"]], bdf$model, mean)
fit <- data.frame(model = names(degf),
df = degf)
for(i in index){
agg <- data.frame(model = names(degf),
mean = tapply(bdf[[i]], bdf$model, mean),
range = paste(format(round(tapply(bdf[[i]], bdf$model, min), digits = digits), nsmall = digits), "-",
format(round(tapply(bdf[[i]], bdf$model, max), digits = digits), nsmall = digits)))
# hist = tapply(bdf[[index]], bdf$factors, function(x) skimr::skim(x)[["numeric.hist"]])
names(agg) <- c("model", paste(c("mean", "range"), i, sep = "."))
# joining into single table
fit <- merge(x = fit, y = agg, by = "model", all.x = TRUE, sort = FALSE)
}
fit
mfits <- k_model_fit(kfa, index = index, by.fold = FALSE)
kfa <- example
index = c("chisq", "cfi", "rmsea")
mfits <- k_model_fit(kfa, index = index, by.fold = FALSE)
mfits
kfits
mnames <- unique(unlist(lapply(kfa$cfas, names))) # model names
mnames
names(sim.boxes)
colnames(sim.boxes)
length(colnames(sim.boxes))
example <- kfa(variables = sim.boxes,
k = NULL, # prompts power analysis to determine number of folds
custom.cfas = box2)
box2 <- custom2 <- paste0("f1 =~ ", paste(colnames(sim.boxes)[1:10], collapse = " + "),
"\nf2 =~ ",paste(colnames(sim.boxes)[11:20], collapse = " + "))
box2 <- custom2 <- paste0("f1 =~ ", paste(colnames(sim.boxes)[1:10], collapse = " + "),
"\nf2 =~ ",paste(colnames(sim.boxes)[11:20], collapse = " + "))
rm(custom2)
example <- kfa(variables = sim.boxes,
k = NULL, # prompts power analysis to determine number of folds
custom.cfas = box2)
class(example$cfas[[1]]$`1-factor`)
fscores
mirt::fscores
lavaan::cfa
lavaan::eval
lavaan:::eval
mnames <- unique(unlist(lapply(example$cfas, names))) # model names
mnames
example$efa.structures
example <- kfa(variables = sim.boxes,
k = NULL, # prompts power analysis to determine number of folds
custom.cfas = box2)
mnames
example$cfa.syntax
example$cfas[[1]]
names(example$cfas[[1]])
names(example$cfas[[2]])
names(example$cfas[[3]])
names(example$cfa.syntax)
example$cfa.syntax
names(example$cfa.syntax[[1]])
test <- example$cfa.syntax
test
test <- example$cfa.syntax[[]]
test
test <- example$cfa.syntax[[1]]
test[[1]]
?grepl
box2 <- paste0("b1 =~ ", paste(colnames(sim.boxes)[1:10], collapse = " + "),
"\nb2 =~ ",paste(colnames(sim.boxes)[11:20], collapse = " + "))
example <- kfa(variables = sim.boxes,
k = NULL, # prompts power analysis to determine number of folds
custom.cfas = box2)
example$cfa.syntax
library(kfa)
