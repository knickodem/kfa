# Currently assumes the first element is a 1 factor model; need a more robust check
kcorrs[[1]] <- NULL
kflag[[1]] <- NA
for(n in 2:m){
cor.lv <- vector("list", k) # latent variable correlation matrix
cor.flag <- vector("list", k) # count of correlations above flag threshold
for(f in 1:k){
if(length(kfa[[f]]) >= n){
cor.lv[[f]] <- lavaan::lavInspect(kfa[[f]][[n]], "cor.lv")
cor.flag[[f]] <- rowSums(cor.lv[[f]] > flag) - 1 # minus diagonal which will always be TRUE
}
}
## count of folds with a correlation over flag threshold
fc <- unlist(cor.flag)
cflag <- tapply(fc, names(fc), function(x) sum(x > flag)) # for each factor
kflag[[n]] <- sum(unlist(lapply(cor.flag, sum)) > 0)      # for the model
## mean correlation across folds
cor.lv <- cor.lv[lengths(cor.lv) != 0] # removes NULL elements for folds were model was not run
aggcorrs <- Reduce(`+`, cor.lv) / length(cor.lv)
aggcorrs[upper.tri(aggcorrs, diag = FALSE)] <- NA
aggcorrs <- cbind(data.frame(rn = row.names(aggcorrs)),
aggcorrs, data.frame(flag = cflag))
kcorrs[[n]] <- aggcorrs
}
cor.lv <- vector("list", k) # latent variable correlation matrix
cor.flag <- vector("list", k) # count of correlations above flag threshold
for(f in 1:k){
if(length(kfa[[f]]) >= n){
cor.lv[[f]] <- lavaan::lavInspect(kfa[[f]][[n]], "cor.lv")
cor.flag[[f]] <- rowSums(cor.lv[[f]] > flag) - 1 # minus diagonal which will always be TRUE
}
}
cor.lv
kstudent$cfa.syntax
kstudent$cfas[[1]][[4]]
length(kstudent$cfas[[1]])
class(kstudent$cfas[[1]])
lapply(kstudent$cfas[[1]], class)
nameds(kstudent$cfas[[1]])
names(kstudent$cfas[[1]])
names(kstudent$cfa,syntax[[1]])
names(kstudent$cfa.syntax)
names(kstudent$cfa.syntax[[1]])
names(kstudent$efa.structures)
names(kstudent$efa.structures[[1]])
names(kstudent$efa.structures[[1]])
kstudent$efa.structures[[1]]
kstudent$efa.structures
loads
cfas <- kstudent$cfas
k <- length(cfas) # number of folds
m <- max(unlist(lapply(cfas, length))) # maximum number of models per fold
vnames <- dimnames(lavaan::lavInspect(cfas[[1]][[1]], "sampstat")$cov)[[1]] # variable names
mnames <- unique(unlist(lapply(cfas, names))) # model names
mnames
klambdas <- vector("list", m)  # factor loadings across folds
lflag <- vector("integer", m)  # low loading flag
hflag <- vector("integer", m)  # heywood case flag
for(n in mnames){
lambdas <- vector("list", k)
thetas <- vector("list", k)
load.flag <- vector("integer", k)
hey.flag <- vector("integer", k)
for(f in 1:k){
if(n %in% names(cfas[[f]])){
## gather standardized loadings
lambdas[[f]] <- subset(lavaan::standardizedSolution(cfas[[f]][[n]], "std.lv", se = FALSE),
op == "=~")
# flag for model summary table
load.flag[[f]] <- sum(lambdas[[f]]$est.std < flag)
## gather residual variances
thetas[[f]] <- subset(lavaan::parameterestimates(cfas[[f]][[n]], se = FALSE),
op == "~~" & lhs %in% vnames & lhs == rhs)
# flag for model summary table
hey.flag[[f]] <- sum(thetas[[f]]$est < 0)
}
}
lambdas <- do.call("rbind", lambdas)
thetas <- do.call("rbind", thetas)
klambdas[[n]] <- data.frame(variable = vnames,
mean = tapply(lambdas$est.std, lambdas$rhs, mean),
range = paste(format(round(tapply(lambdas$est.std, lambdas$rhs, min), digits = digits), nsmall = digits), "-",
format(round(tapply(lambdas$est.std, lambdas$rhs, max), digits = digits), nsmall = digits)),
`loading flag` = tapply(lambdas$est.std, lambdas$rhs, function(x) sum(x < flag)),
`heywood flag` = tapply(thetas$est, thetas$rhs, function(x) sum(x < 0)),
check.names = FALSE)
## count of folds with a loading under flag threshold
lflag[[n]] <- sum(load.flag > 0)
hflag[[n]] <- sum(hey.flag > 0)
}
digits <- 2
flag <- .30
klambdas <- vector("list", m)  # factor loadings across folds
lflag <- vector("integer", m)  # low loading flag
hflag <- vector("integer", m)  # heywood case flag
for(n in mnames){
lambdas <- vector("list", k)
thetas <- vector("list", k)
load.flag <- vector("integer", k)
hey.flag <- vector("integer", k)
for(f in 1:k){
if(n %in% names(cfas[[f]])){
## gather standardized loadings
lambdas[[f]] <- subset(lavaan::standardizedSolution(cfas[[f]][[n]], "std.lv", se = FALSE),
op == "=~")
# flag for model summary table
load.flag[[f]] <- sum(lambdas[[f]]$est.std < flag)
## gather residual variances
thetas[[f]] <- subset(lavaan::parameterestimates(cfas[[f]][[n]], se = FALSE),
op == "~~" & lhs %in% vnames & lhs == rhs)
# flag for model summary table
hey.flag[[f]] <- sum(thetas[[f]]$est < 0)
}
}
lambdas <- do.call("rbind", lambdas)
thetas <- do.call("rbind", thetas)
klambdas[[n]] <- data.frame(variable = vnames,
mean = tapply(lambdas$est.std, lambdas$rhs, mean),
range = paste(format(round(tapply(lambdas$est.std, lambdas$rhs, min), digits = digits), nsmall = digits), "-",
format(round(tapply(lambdas$est.std, lambdas$rhs, max), digits = digits), nsmall = digits)),
`loading flag` = tapply(lambdas$est.std, lambdas$rhs, function(x) sum(x < flag)),
`heywood flag` = tapply(thetas$est, thetas$rhs, function(x) sum(x < 0)),
check.names = FALSE)
## count of folds with a loading under flag threshold
lflag[[n]] <- sum(load.flag > 0)
hflag[[n]] <- sum(hey.flag > 0)
}
n <- "4-factor"
lambdas <- vector("list", k)
thetas <- vector("list", k)
load.flag <- vector("integer", k)
hey.flag <- vector("integer", k)
for(f in 1:k){
if(n %in% names(cfas[[f]])){
## gather standardized loadings
lambdas[[f]] <- subset(lavaan::standardizedSolution(cfas[[f]][[n]], "std.lv", se = FALSE),
op == "=~")
# flag for model summary table
load.flag[[f]] <- sum(lambdas[[f]]$est.std < flag)
## gather residual variances
thetas[[f]] <- subset(lavaan::parameterestimates(cfas[[f]][[n]], se = FALSE),
op == "~~" & lhs %in% vnames & lhs == rhs)
# flag for model summary table
hey.flag[[f]] <- sum(thetas[[f]]$est < 0)
}
}
lambdas
kstudent$efa.structures[[4]]
length(kstudent$efa.structures)
lambdas <- do.call("rbind", lambdas)
thetas <- do.call("rbind", thetas)
lambdas
klambdas[[n]] <- data.frame(variable = vnames,
mean = tapply(lambdas$est.std, lambdas$rhs, mean),
range = paste(format(round(tapply(lambdas$est.std, lambdas$rhs, min), digits = digits), nsmall = digits), "-",
format(round(tapply(lambdas$est.std, lambdas$rhs, max), digits = digits), nsmall = digits)),
`loading flag` = tapply(lambdas$est.std, lambdas$rhs, function(x) sum(x < flag)),
`heywood flag` = tapply(thetas$est, thetas$rhs, function(x) sum(x < 0)),
check.names = FALSE)
klambdas
klambdas <- vector("list", m)  # factor loadings across folds
names(klambdas) <- mnames
lflag <- vector("integer", m)  # low loading flag
names(lflag) <- mnames
hflag <- vector("integer", m)  # heywood case flag
names(hflag) <- mnames
klambdas
for(n in mnames){
lambdas <- vector("list", k)
thetas <- vector("list", k)
load.flag <- vector("integer", k)
hey.flag <- vector("integer", k)
for(f in 1:k){
if(n %in% names(cfas[[f]])){
## gather standardized loadings
lambdas[[f]] <- subset(lavaan::standardizedSolution(cfas[[f]][[n]], "std.lv", se = FALSE),
op == "=~")
# flag for model summary table
load.flag[[f]] <- sum(lambdas[[f]]$est.std < flag)
## gather residual variances
thetas[[f]] <- subset(lavaan::parameterestimates(cfas[[f]][[n]], se = FALSE),
op == "~~" & lhs %in% vnames & lhs == rhs)
# flag for model summary table
hey.flag[[f]] <- sum(thetas[[f]]$est < 0)
}
}
lambdas <- do.call("rbind", lambdas)
thetas <- do.call("rbind", thetas)
klambdas[[n]] <- data.frame(variable = vnames,
mean = tapply(lambdas$est.std, lambdas$rhs, mean),
range = paste(format(round(tapply(lambdas$est.std, lambdas$rhs, min), digits = digits), nsmall = digits), "-",
format(round(tapply(lambdas$est.std, lambdas$rhs, max), digits = digits), nsmall = digits)),
`loading flag` = tapply(lambdas$est.std, lambdas$rhs, function(x) sum(x < flag)),
`heywood flag` = tapply(thetas$est, thetas$rhs, function(x) sum(x < 0)),
check.names = FALSE)
## count of folds with a loading under flag threshold
lflag[[n]] <- sum(load.flag > 0)
hflag[[n]] <- sum(hey.flag > 0)
}
klambdas
flag <- .90
cfas <- kstudent$cfas
k <- length(cfas)
m <- max(unlist(lapply(cfas, length)))
mnames <- unique(unlist(lapply(cfas, names))) # model names
kcorrs <- vector("list", m)
kflag <- vector("integer", m)
m
mnames
# Currently assumes the first element is a 1 factor model; need a more robust check
kcorrs[[1]] <- NULL
kflag[[1]] <- NA
mnames[[n]]
mnames <- unique(unlist(lapply(cfas, names))) # model names
m <- length(mnames) #max(unlist(lapply(cfas, length))) # maximum number of models per fold
k <- length(cfas) # number of folds
mnames
n <- "4-factor"
n <- 4
cor.lv <- vector("list", k) # latent variable correlation matrix
cor.flag <- vector("list", k) # count of correlations above flag threshold
mnames[[n]]
names(cfas[[f]]
)
# Currently assumes the first element is a 1 factor model; need a more robust check
kcorrs[[1]] <- NULL
kflag[[1]] <- NA
for(n in 2:m){
cor.lv <- vector("list", k) # latent variable correlation matrix
cor.flag <- vector("list", k) # count of correlations above flag threshold
for(f in 1:k){
if(mnames[[n]] %in% names(cfas[[f]])){
cor.lv[[f]] <- lavaan::lavInspect(cfas[[f]][[n]], "cor.lv")
cor.flag[[f]] <- rowSums(cor.lv[[f]] > flag) - 1 # minus diagonal which will always be TRUE
}
}
## count of folds with a correlation over flag threshold
fc <- unlist(cor.flag)
cflag <- tapply(fc, names(fc), function(x) sum(x > flag)) # for each factor
kflag[[n]] <- sum(unlist(lapply(cor.flag, sum)) > 0)      # for the model
## mean correlation across folds
cor.lv <- cor.lv[lengths(cor.lv) != 0] # removes NULL elements for folds were model was not run
aggcorrs <- Reduce(`+`, cor.lv) / length(cor.lv)
aggcorrs[upper.tri(aggcorrs, diag = FALSE)] <- NA
aggcorrs <- cbind(data.frame(rn = row.names(aggcorrs)),
aggcorrs, data.frame(flag = cflag))
kcorrs[[n]] <- aggcorrs
}
n <- 4
cor.lv <- vector("list", k) # latent variable correlation matrix
cor.flag <- vector("list", k) # count of correlations above flag threshold
for(f in 1:k){
if(mnames[[n]] %in% names(cfas[[f]])){
cor.lv[[f]] <- lavaan::lavInspect(cfas[[f]][[n]], "cor.lv")
cor.flag[[f]] <- rowSums(cor.lv[[f]] > flag) - 1 # minus diagonal which will always be TRUE
}
}
cor.lv
cor.flag
## count of folds with a correlation over flag threshold
fc <- unlist(cor.flag)
fc
cflag <- tapply(fc, names(fc), sum) # for each factor
cflag
lapply(cor.flag, sum)
cflag
## mean correlation across folds
cor.lv <- cor.lv[lengths(cor.lv) != 0] # removes NULL elements for folds were model was not run
aggcorrs <- Reduce(`+`, cor.lv) / length(cor.lv)
aggcorrs[upper.tri(aggcorrs, diag = FALSE)] <- NA
aggcorrs
aggcorrs <- cbind(data.frame(rn = row.names(aggcorrs)),
aggcorrs, data.frame(flag = cflag))
aggcorrs
flag <- .90
cfas <- kstudent$cfas
mnames <- unique(unlist(lapply(cfas, names))) # model names
m <- length(mnames) #max(unlist(lapply(cfas, length))) # maximum number of models per fold
k <- length(cfas) # number of folds
kcorrs <- vector("list", m)
kflag <- vector("integer", m)
# Currently assumes the first element is a 1 factor model; need a more robust check
kcorrs[[1]] <- NULL
kflag[[1]] <- NA
for(n in 2:m){
cor.lv <- vector("list", k) # latent variable correlation matrix
cor.flag <- vector("list", k) # count of correlations above flag threshold
for(f in 1:k){
if(mnames[[n]] %in% names(cfas[[f]])){
cor.lv[[f]] <- lavaan::lavInspect(cfas[[f]][[n]], "cor.lv")
cor.flag[[f]] <- rowSums(cor.lv[[f]] > flag) - 1 # minus diagonal which will always be TRUE
}
}
## count of folds with a correlation over flag threshold
fc <- unlist(cor.flag)
cflag <- tapply(fc, names(fc), sum) # for each factor
kflag[[n]] <- sum(unlist(lapply(cor.flag, sum)) > 0)      # for the model
## mean correlation across folds
cor.lv <- cor.lv[lengths(cor.lv) != 0] # removes NULL elements for folds were model was not run
aggcorrs <- Reduce(`+`, cor.lv) / length(cor.lv)
aggcorrs[upper.tri(aggcorrs, diag = FALSE)] <- NA
aggcorrs <- cbind(data.frame(rn = row.names(aggcorrs)),
aggcorrs, data.frame(flag = cflag))
kcorrs[[n]] <- aggcorrs
}
kcorrs
cor.lv <- vector("list", k) # latent variable correlation matrix
cor.flag <- vector("list", k) # count of correlations above flag threshold
for(f in 1:k){
if(mnames[[n]] %in% names(cfas[[f]])){
cor.lv[[f]] <- lavaan::lavInspect(cfas[[f]][[n]], "cor.lv")
cor.flag[[f]] <- rowSums(cor.lv[[f]] > flag) - 1 # minus diagonal which will always be TRUE
}
}
cor.lv
mnames <- unique(unlist(lapply(cfas, names))) # model names
m <- length(mnames) #max(unlist(lapply(cfas, length))) # maximum number of models per fold
k <- length(cfas) # number of folds
kcorrs <- vector("list", m)
kflag <- vector("integer", m)
# Currently assumes the first element is a 1 factor model; need a more robust check
kcorrs[[1]] <- NULL
kflag[[1]] <- NA
for(n in 2:m){
cor.lv <- vector("list", k) # latent variable correlation matrix
cor.flag <- vector("list", k) # count of correlations above flag threshold
for(f in 1:k){
if(mnames[[n]] %in% names(cfas[[f]])){
cor.lv[[f]] <- lavaan::lavInspect(cfas[[f]][[mnames[[n]]]], "cor.lv")
cor.flag[[f]] <- rowSums(cor.lv[[f]] > flag) - 1 # minus diagonal which will always be TRUE
}
}
## count of folds with a correlation over flag threshold
fc <- unlist(cor.flag)
cflag <- tapply(fc, names(fc), sum) # for each factor
kflag[[n]] <- sum(unlist(lapply(cor.flag, sum)) > 0)      # for the model
## mean correlation across folds
cor.lv <- cor.lv[lengths(cor.lv) != 0] # removes NULL elements for folds were model was not run
aggcorrs <- Reduce(`+`, cor.lv) / length(cor.lv)
aggcorrs[upper.tri(aggcorrs, diag = FALSE)] <- NA
aggcorrs <- cbind(data.frame(rn = row.names(aggcorrs)),
aggcorrs, data.frame(flag = cflag))
kcorrs[[n]] <- aggcorrs
}
kcorrs
kcorrs <- vector("list", m)
kflag <- vector("integer", m)
# Currently assumes the first element is a 1 factor model; need a more robust check
kcorrs[[1]] <- NULL
kflag[[1]] <- NA
for(n in 2:m){
cor.lv <- vector("list", k) # latent variable correlation matrix
cor.flag <- vector("list", k) # count of correlations above flag threshold
for(f in 1:k){
if(mnames[[n]] %in% names(cfas[[f]])){
cor.lv[[f]] <- lavaan::lavInspect(cfas[[f]][[mnames[[n]]]], "cor.lv")
cor.flag[[f]] <- rowSums(cor.lv[[f]] > flag) - 1 # minus diagonal which will always be TRUE
}
}
## count of folds with a correlation over flag threshold
fc <- unlist(cor.flag)
cflag <- tapply(fc, names(fc), function(x) sum(x > 0)) # for each factor
kflag[[n]] <- sum(unlist(lapply(cor.flag, sum)) > 0)      # for the model
## mean correlation across folds
cor.lv <- cor.lv[lengths(cor.lv) != 0] # removes NULL elements for folds were model was not run
aggcorrs <- Reduce(`+`, cor.lv) / length(cor.lv)
aggcorrs[upper.tri(aggcorrs, diag = FALSE)] <- NA
aggcorrs <- cbind(data.frame(rn = row.names(aggcorrs)),
aggcorrs, data.frame(flag = cflag))
kcorrs[[n]] <- aggcorrs
}
kcorrs
kflag
digits <- 2
flag <- .60
cfas <- kstudent$cfas
mnames <- unique(unlist(lapply(cfas, names))) # model names
m <- length(mnames) #max(unlist(lapply(cfas, length))) # maximum number of models per fold
k <- length(cfas) # number of folds
mnames <- unique(unlist(lapply(cfas, names))) # model names
m <- length(mnames) #max(unlist(lapply(cfas, length))) # maximum number of models per fold
k <- length(cfas) # number of folds
krels <- vector("list", m)
n <- 1
rels <- vector("list", k)
rel.flag <- vector("integer", k)
for(f in 1:k){
if(mnames[[n]] %in% names(cfas[[f]])){
rels[[f]] <- t(suppressMessages(semTools::reliability(cfas[[f]][[mnames[[n]]]])[c(1,4),]))
rel.flag[[f]] <- sum(rels[[f]][,2] < flag) # flag based on omega, not alpha
}
}
rels
rel.flag
## mean reliability across folds
aos <- do.call("rbind", rels)
aos
if(n == 1){
fn <- "f1"
fnames <- rep(fn, nrow(aos))
} else{
rels <- rels[lengths(rels) != 0] # removes NULL elements for folds were model was not run
fn <- dimnames(rels[[1]])[[1]]  # grabs names from first fold; should be the same in all folds
fnames <- dimnames(aos)[[1]] # should be the equivalent of rep(fn, nrow(aos))
}
tapply(aos[, 2], fnames, function(x) sum(x < flag)
)
digits <- 2
flag <- .60
cfas <- kstudent$cfas
mnames <- unique(unlist(lapply(cfas, names))) # model names
m <- length(mnames) #max(unlist(lapply(cfas, length))) # maximum number of models per fold
k <- length(cfas) # number of folds
krels <- vector("list", m)
kflag <- vector("integer", m)
for(n in 1:m){
rels <- vector("list", k)
rel.flag <- vector("integer", k)
for(f in 1:k){
if(mnames[[n]] %in% names(cfas[[f]])){
rels[[f]] <- t(suppressMessages(semTools::reliability(cfas[[f]][[mnames[[n]]]])[c(1,4),]))
rel.flag[[f]] <- sum(rels[[f]][,2] < flag) # flag based on omega, not alpha
}
}
## mean reliability across folds
aos <- do.call("rbind", rels)
if(n == 1){
fn <- "f1"
fnames <- rep(fn, nrow(aos))
} else{
rels <- rels[lengths(rels) != 0] # removes NULL elements for folds were model was not run
fn <- dimnames(rels[[1]])[[1]]  # grabs names from first fold; should be the same in all folds
fnames <- dimnames(aos)[[1]] # should be the equivalent of rep(fn, nrow(aos))
}
krels[[n]] <- data.frame(factor = fn,
o.mean = tapply(aos[, 2], fnames, mean),
o.range = paste(format(round(tapply(aos[, 2], fnames, min), digits = digits), nsmall = digits), "-",
format(round(tapply(aos[, 2], fnames, max), digits = digits), nsmall = digits)),
o.flag = tapply(aos[, 2], fnames, function(x) sum(x < flag)),
a.mean = tapply(aos[, 1], fnames, mean),
a.range = paste(format(round(tapply(aos[, 1], fnames, min), digits = digits), nsmall = digits), "-",
format(round(tapply(aos[, 1], fnames, max), digits = digits), nsmall = digits)),
a.flag = tapply(aos[, 1], fnames, function(x) sum(x < flag)))
## count of folds with a reliabilities below flag threshold
kflag[[n]] <- sum(rel.flag > 0)
}
names(krels) <- mnames
names(kflag) <- mnames
krels
kflag
kfit <- k_model_fit(kstudent)
mfit <- k_model_fit(kstudent, by.fold = FALSE)
kfit
mfit
agg_model_fit(kfit)
appendix <- get_appendix(mfit)
library(kfa)
# Run report
kfa_report(kstudent,
file.name = "kfa_students_test",
report.title = "K-fold Factor Analysis - Lebanon Students")
warnings()
tictoc::tic()
loads <- agg_loadings(kstudent)
tictoc::toc() #.16
tictoc::tic()
cors <- agg_cors(kstudent)
tictoc::toc() #.04
tictoc::tic()
rels <- agg_rels(kstudent)
tictoc::toc() #74.9
strux <- model_structure(kstudent, which = "cfa")
# Multiple structures from EFA
strux <- strux[c("model", "folds")]
names(strux) <- c("model", "mode structure")
# flags from CFA models
cfas <- kstudent$cfas
k <- length(cfas)
m <- max(unlist(lapply(cfas, length)))
## Flagging non-convergence and non-positive definite matrix warnings
cnvgd <- vector("list", k)
hey <- vector("list", k)
for(f in 1:k){
## convergence status of each model
cnvgd[[f]] <- lapply(cfas[[f]], lavaan::lavInspect, "converged")
## presence of non-positive definite matrix (and heywood cases) in each model
hey[[f]] <- lapply(cfas[[f]], lavaan::lavInspect, "post.check")
}
# flagged if either indicates an improper solution
temp <- c(unlist(cnvgd) == FALSE, unlist(hey) == FALSE)
improper <-tapply(temp, names(temp), sum)
## joining flags into data.frame
flags <- data.frame(model = unique(unlist(lapply(cfas, names))),  # assumes first fold contains all models in the same order as other folds
`improper solution` = improper,
`heywood item` = loads$heywood,
`low loading` = loads$flag,
`high factor correlation` = cors$flag,
`low scale reliability` = rels$flag,
check.names = FALSE)
flags
strux
model_structure(kstudent, which = "cfa")
library(kfa)
strux <- model_structure(kstudent, which = "cfa")
strux
# Multiple structures from EFA
strux <- strux[c("model", "folds")]
names(strux) <- c("model", "mode structure")
strux
?family
roxygen2::roxygenise()
roxygen2::roxygenise()
