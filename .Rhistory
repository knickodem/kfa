sample.nobs = nobs,
# estimator = "DWLS",
ordered = names(items),
parameterization = "theta",
se = "none")
## direct with only raw data input
lv.dat <- lavaan::lavaan(model = st.mod,
data = items,
# estimator = "DWLS",
ordered = names(items),
parameterization = "theta",
se = "none")
# same results
get_std_loadings(st.mat)
get_std_loadings(st.dat)
get_std_loadings(lv.mat)
get_std_loadings(lv.dat)
all.equal(lavaan::lavInspect(lv.mat, "options"), lavaan::lavInspect(lv.dat, "options"))
all.equal(lavaan::lavInspect(lv.mat, "options"), lavaan::lavInspect(st.mat, "options"))
## direct with polychoric correlation
lv.mat <- lavaan::cfa(model = st.mod,
data = items,
sample.cov = cormat,
sample.nobs = nobs,
# estimator = "DWLS",
ordered = names(items),
parameterization = "theta",
se = "none")
## direct with only raw data input
lv.dat <- lavaan::cfa(model = st.mod,
data = items,
# estimator = "DWLS",
ordered = names(items),
parameterization = "theta",
se = "none")
# same results
get_std_loadings(st.mat)
get_std_loadings(st.dat)
get_std_loadings(lv.mat)
get_std_loadings(lv.dat)
lapply(list(st.mat, st.dat, lv.mat, lv.dat), function(x) lavaan::lavInspect(x, "categorical"))
lapply(list(st.mat, st.dat, lv.mat, lv.dat), function(x) lavaan::lavInspect(x, "parameterization"))
lapply(list(st.mat, st.dat, lv.mat, lv.dat), function(x) lavaan::lavInspect(x, "iterations"))
lapply(list(st.mat, st.dat, lv.mat, lv.dat), function(x) lavaan::lavInspect(x, "options")$missing)
lapply(list(st.mat, st.dat, lv.mat, lv.dat), function(x) lavaan::lavInspect(x, "est"))
all.equal(lavaan::lavInspect(lv.mat, "options"), lavaan::lavInspect(lv.dat, "options"))
all.equal(lavaan::lavInspect(lv.mat, "options"), lavaan::lavInspect(st.mat, "options"))
## direct with only raw data input
lv.dat <- lavaan::cfa(model = st.mod,
data = items,
# estimator = "DWLS",
ordered = names(items),
parameterization = "delta",
se = "none")
## direct with polychoric correlation
lv.mat <- lavaan::cfa(model = st.mod,
data = items,
sample.cov = cormat,
sample.nobs = nobs,
# estimator = "DWLS",
ordered = names(items),
parameterization = "delta",
se = "none")
get_std_loadings(st.dat)
get_std_loadings(lv.mat)
lapply(list(st.mat, st.dat, lv.mat, lv.dat), function(x) lavaan::lavInspect(x, "categorical"))
lapply(list(st.mat, st.dat, lv.mat, lv.dat), function(x) lavaan::lavInspect(x, "parameterization"))
lapply(list(st.mat, st.dat, lv.mat, lv.dat), function(x) lavaan::lavInspect(x, "iterations"))
lapply(list(st.mat, st.dat, lv.mat, lv.dat), function(x) lavaan::lavInspect(x, "options")$missing)
lapply(list(st.mat, st.dat, lv.mat, lv.dat), function(x) lavaan::lavInspect(x, "est"))
all.equal(lavaan::lavInspect(lv.mat, "options"), lavaan::lavInspect(lv.dat, "options"))
all.equal(lavaan::lavInspect(lv.mat, "options"), lavaan::lavInspect(st.mat, "options"))
# Threshold estimates
all.equal(lavaan::lavInspect(lv.mat, "est")$tau, lavaan::lavInspect(lv.dat, "est")$tau)
all.equal(lavaan::lavInspect(lv.mat, "est")$tau, lavaan::lavInspect(st.mat, "est")$tau)
## direct with polychoric correlation
lv.mat <- lavaan::cfa(model = st.mod,
data = items,
sample.cov = cormat,
sample.nobs = nobs,
# estimator = "DWLS",
ordered = names(items),
parameterization = "theta",
se = "none")
## direct with only raw data input
lv.dat <- lavaan::cfa(model = st.mod,
data = items,
# estimator = "DWLS",
ordered = names(items),
parameterization = "theta",
se = "none")
all.equal(lavaan::lavInspect(lv.mat, "est")$tau, lavaan::lavInspect(st.mat, "est")$tau) # no
lavaan::lavInspect(lv.dat, "options")$estimator
lavaan::lavInspect(prelim, "sampstat")
th <- lavaan::lavInspect(prelim, "sampstat")$th
## Common correlation matrix
prelim <- lavaan::lavCor(items,
ordered = names(items),
missing = "listwise",
output = "fit",
cor.smooth = FALSE) # could include a cluster =  argument
nobs <- lavaan::lavInspect(prelim, "nobs")
## Common correlation matrix
prelim <- lavaan::lavCor(items,
ordered = names(items),
missing = "pairwise",
output = "fit",
cor.smooth = FALSE) # could include a cluster =  argument
nobs <- lavaan::lavInspect(prelim, "nobs")
wlsv <- lavaan::lavInspect(prelim, "wls.v")
lavaan::lavInspect(prelim, "options")$estimator
cormat
nacov <- lavaan::lavInspect(prelim, "gamma")
cormat <- lavaan::lavInspect(prelim, "cor.ov") # same as lavaan::lavInspect(prelim, "sampstat")$cov
## Common correlation matrix
prelim <- lavaan::lavCor(items,
ordered = names(items),
# estimator = "DWLS",
missing = "pairwise",
output = "fit",
cor.smooth = FALSE) # could include a cluster =  argument
nobs <- lavaan::lavInspect(prelim, "nobs")
wlsv <- lavaan::lavInspect(prelim, "wls.v")
lavaan::lavInspect(prelim, "options")$estimator
## Common correlation matrix
prelim <- lavaan::lavCor(object = items,
ordered = names(items),
estimator = "DWLS",  # must specify estimator, otherwise defaults to none
missing = "pairwise",
output = "fit",
cor.smooth = FALSE) # could include a cluster =  argument
nobs <- lavaan::lavInspect(prelim, "nobs")
wlsv <- lavaan::lavInspect(prelim, "wls.v")
nacov <- lavaan::lavInspect(prelim, "gamma")
cormat <- lavaan::lavInspect(prelim, "cor.ov") # same as lavaan::lavInspect(prelim, "sampstat")$cov
itrtns <- lavaan::lavInspect(prelim, "iterations")
th <- lavaan::lavInspect(prelim, "sampstat")$th
lavaan::lavInspect(prelim, "options")$estimator
## direct with polychoric correlation
lv.mat <- lavaan::cfa(model = st.mod,
data = items,
sample.cov = cormat,
sample.nobs = nobs,
# sample.th = ,
# estimator = "DWLS",
ordered = names(items),
parameterization = "theta",
se = "none")
## direct with only raw data input
lv.dat <- lavaan::cfa(model = st.mod,
data = items,
# estimator = "DWLS",
ordered = names(items),
parameterization = "theta",
se = "none")
all.equal(lavaan::lavInspect(prelim, "est")$tau, th) # yes
th
lavaan::lavInspect(prelim, "est")$tau
class(lavaan::lavInspect(prelim, "est")$tau)
class(th)
View(wlsv)
View(wlsv)
th
cortmat
cormat
all.equal(lavaan::lavInspect(lv.mat, "sampstat")$th, th) # yes
lapply(list(st.mat, st.dat, lv.mat, lv.dat), function(x) lavaan::lavInspect(x, "categorical"))
lapply(list(st.mat, st.dat, lv.mat, lv.dat), function(x) lavaan::lavInspect(x, "options")$missing)
lapply(list(st.mat, st.dat, lv.mat, lv.dat), function(x) lavaan::lavInspect(x, "nobs"))
## mat is slightly faster;
inputtype <- microbenchmark::microbenchmark(
mat = lavaan::cfa(model = st.mod,
data = items,
sample.cov = cormat,
sample.nobs = nobs,
# sample.th = ,
# estimator = "DWLS",
ordered = names(items),
parameterization = "delta",
se = "none"),
dat = lavaan::cfa(model = st.mod,
data = items,
# estimator = "DWLS",
ordered = names(items),
parameterization = "delta",
se = "none"),
times = 20
)
inputtype
matonly <- lavaan::cfa(model = st.mod,
sample.cov = cormat,
sample.nobs = nobs,
sample.th = th,
WLS.V = wlsv,
NACOV = nacov,
estimator = "DWLS",
parameterization = "delta",
se = "none")
tau <- lavaan::lavInspect(prelim, "est")$tau
matonly <- lavaan::cfa(model = st.mod,
sample.cov = cormat,
sample.nobs = nobs,
sample.th = tau,
WLS.V = wlsv,
NACOV = nacov,
estimator = "DWLS",
parameterization = "delta",
se = "none")
matonly <- lavaan::cfa(model = st.mod,
sample.cov = cormat,
sample.nobs = nobs,
WLS.V = wlsv,
NACOV = nacov,
estimator = "DWLS",
parameterization = "delta",
se = "none")
warnings()
lavaan::summary(matonly)
rs.mod <- regsem::efaModel(3, names(items))
rs <- lavaan::cfa(model = rs.mod,
data = items,
ordered = names(items),
parameterization = "theta",
se = "none")
rs <- lavaan::cfa(model = rs.mod,
data = items,
ordered = names(items),
parameterization = "theta",
se = "none",
test = "none")
#### Comparing time difference when cor matrix is provided or not ####
## mat is slightly faster; mean = 11.8 vs. 12.1
# not sure if the correlation matrix is actually used or recalculated
inputtype <- microbenchmark::microbenchmark(
mat = lavaan::cfa(model = st.mod,
data = items,
sample.cov = cormat,
sample.nobs = nobs,
# estimator = "DWLS",
ordered = names(items),
parameterization = "delta",
se = "none",
test = "none"),
dat = lavaan::cfa(model = st.mod,
data = items,
# estimator = "DWLS",
ordered = names(items),
parameterization = "delta",
se = "none",
test = "none"),
times = 20
)
inputtype
rs.v.st <- microbenchmark::microbenchmark(
rs = lavaan::cfa(model = rs.mod,
data = items,
ordered = names(items),
parameterization = "delta",
se = "none",
test = "none"),
st <- lavaan::cfa(model = st.mod,
data = items,
ordered = names(items),
parameterization = "delta",
se = "none",
test = "none"),
times = 20)
rs.v.st
cat(st.mod)
all.equal(get_std_loadings(lv.dat), get_std_loadings(rs))
lapply(list(lv.dat, rs),function(x) lavaan::lavInspect(x, "iterations"))
get_std_loadings(rs)
get_std_loadings(lv.dat)
## Import data
student <- read.csv("C:/Users/kylenick/University of North Carolina at Chapel Hill/Halpin, Peter Francis - UNC_stat_projets/EFA&CFA/scaledim/student_survey-latest.csv")
# extract items
items <- student[ ,grepl("^a11", names(student))]
?lavaan::parameterEstimates
?subset
## polychoric correlation matrix
microbenchmark::microbenchmark(
prelim = lavaan::lavCor(object = items,
ordered = names(items),
estimator = "DWLS",  # must specify estimator, otherwise defaults to none
missing = "pairwise",
output = "fit",
cor.smooth = FALSE), # could include a cluster =  argument
times = 20)
?polycor::polychor
?polycor::hetcor
# ---- Using correlation matrix in lavaan -----------------
test <- as.data.frame(lapply(items, as.ordered))
View(test)
microbenchmark::microbenchmark(
poly = polycor::hetcor(object = as.data.frame(lapply(items,as.ordered)),
use = "pairwise.complete.obs",
std.err = FALSE), # could include a cluster =  argument
times = 20)
microbenchmark::microbenchmark(
poly = polycor::hetcor(data = as.data.frame(lapply(items,as.ordered)),
use = "pairwise.complete.obs",
std.err = FALSE), # could include a cluster =  argument
times = 20)
## Import data
student <- read.csv("C:/Users/kylenick/University of North Carolina at Chapel Hill/Halpin, Peter Francis - UNC_stat_projets/EFA&CFA/scaledim/student_survey-latest.csv")
# extract items
items <- student[ ,grepl("^a11", names(student))]
prelim <- lavaan::lavCor(object = items,
ordered = names(items),
estimator = "DWLS",  # must specify estimator, otherwise defaults to none
missing = "pairwise",
output = "fit",
cor.smooth = FALSE)
lavInspect(prelim, "th.idx")
lavaan::lavInspect(prelim, "th.idx")
th
th <- lavaan::lavInspect(prelim, "sampstat")$th # same values as lavaan::lavInspect(prelim, "est")$tau
th
attr(th, "th.idx") <- lavaan::lavInspect(prelim, "th.idx")
nobs <- lavaan::lavInspect(prelim, "nobs")
wlsv <- lavaan::lavInspect(prelim, "wls.v")
nacov <- lavaan::lavInspect(prelim, "gamma")
cormat <- lavaan::lavInspect(prelim, "sampstat")$cov # same as lavaan::lavInspect(prelim, "cor.ov")
means <- lavInspect(prelim, "sampstat")$mean
th <- lavaan::lavInspect(prelim, "sampstat")$th # same values as lavaan::lavInspect(prelim, "est")$tau
attr(th, "th.idx") <- lavaan::lavInspect(prelim, "th.idx")
means <- lavaan::lavInspect(prelim, "sampstat")$mean
means
## semTools with previously calculated polychoric correlation matrix
st.mat = semTools::efaUnrotate(data = items,
nf = 3,
start = FALSE,
sample.cov = cormat,
sample.nobs = nobs,
ordered = names(items),
parameterization = "theta",
se = "none",
test = "none")
st.mod <- lavaan::lavInspect(st.mat, "call")$model
st.mod
cat(st.mod)
## fit efa with sample statistics
# keep getting errors
matonly <- lavaan::cfa(model = st.mod,
sample.cov = cormat,
sample.nobs = nobs,
sample.mean = means,
sample.th = th,
WLS.V = wlsv,
NACOV = nacov,
estimator = "DWLS",
parameterization = "delta",
se = "none")
lavaan::summary(matonly, fit.measures = TRUE)
dat <- lavaan::cfa(model = st.mod,
data = items,
estimator = "DWLS",
ordered = names(items),
parameterization = "delta",
se = "none")
all.equal(lavaan::parameterestimates(matonly, se = FALSE, zstat = FALSE, pvalue = FALSE, ci = FALSE),
lavaan::parameterestimates(dat, se = FALSE, zstat = FALSE, pvalue = FALSE, ci = FALSE))
avaan::parameterestimates(matonly, se = FALSE, zstat = FALSE, pvalue = FALSE, ci = FALSE)
lavaan::parameterestimates(matonly, se = FALSE, zstat = FALSE, pvalue = FALSE, ci = FALSE)
lavaan::parameterestimates(dat, se = FALSE, zstat = FALSE, pvalue = FALSE, ci = FALSE)
identical(lavaan::parameterestimates(matonly, se = FALSE, zstat = FALSE, pvalue = FALSE, ci = FALSE),
lavaan::parameterestimates(dat, se = FALSE, zstat = FALSE, pvalue = FALSE, ci = FALSE))
dplyr::left_join(lavaan::parameterestimates(matonly, se = FALSE, zstat = FALSE, pvalue = FALSE, ci = FALSE),
lavaan::parameterestimates(dat, se = FALSE, zstat = FALSE, pvalue = FALSE, ci = FALSE))
check <- dplyr::full_join(lavaan::parameterestimates(matonly, se = FALSE, zstat = FALSE, pvalue = FALSE, ci = FALSE),
lavaan::parameterestimates(dat, se = FALSE, zstat = FALSE, pvalue = FALSE, ci = FALSE),
by = c("lhs", "op", "rhs", "label"), suffix = c(".mat", ".dat"))
View(check)
dat <- lavaan::cfa(model = st.mod,
data = items,
estimator = "DWLS",
missing = "pairwise",
ordered = names(items),
parameterization = "delta",
se = "none")
check <- dplyr::full_join(lavaan::parameterestimates(matonly, se = FALSE, zstat = FALSE, pvalue = FALSE, ci = FALSE),
lavaan::parameterestimates(dat, se = FALSE, zstat = FALSE, pvalue = FALSE, ci = FALSE),
by = c("lhs", "op", "rhs", "label"), suffix = c(".mat", ".dat"))
View(check)
#### Comparing time difference when cor matrix is provided or not ####
## mat is slightly faster; mean = 11.8 vs. 12.1
# not sure if the correlation matrix is actually used or recalculated
inputtype <- microbenchmark::microbenchmark(
mat = lavaan::cfa(model = st.mod,
sample.cov = cormat,
sample.nobs = nobs,
sample.mean = means,
sample.th = th,
WLS.V = wlsv,
NACOV = nacov,
estimator = "DWLS",
parameterization = "delta",
se = "none",
test = "none"),
dat = lavaan::cfa(model = st.mod,
data = items,
estimator = "DWLS",
missing = "pairwise",
ordered = names(items),
parameterization = "delta",
se = "none",
test = "none"),
times = 20
)
all.equal(lavaan::parameterestimates(matonly, se = FALSE, zstat = FALSE, pvalue = FALSE, ci = FALSE),
lavaan::parameterestimates(dat, se = FALSE, zstat = FALSE, pvalue = FALSE, ci = FALSE))
inputtype
rs.v.st <- microbenchmark::microbenchmark(
rs = lavaan::cfa(model = rs.mod,
sample.cov = cormat,
sample.nobs = nobs,
sample.mean = means,
sample.th = th,
WLS.V = wlsv,
NACOV = nacov,
estimator = "DWLS",
parameterization = "delta",
se = "none",
test = "none"),
st = lavaan::cfa(model = st.mod,
sample.cov = cormat,
sample.nobs = nobs,
sample.mean = means,
sample.th = th,
WLS.V = wlsv,
NACOV = nacov,
estimator = "DWLS",
parameterization = "delta",
se = "none",
test = "none"),
times = 20)
# ----- Comparing model defined by semTools to model defined by regsem ------------
## Model from regsem
rs.mod <- regsem::efaModel(3, names(items))
rs.mod
rs.v.st <- microbenchmark::microbenchmark(
rs = lavaan::cfa(model = rs.mod,
sample.cov = cormat,
sample.nobs = nobs,
sample.mean = means,
sample.th = th,
WLS.V = wlsv,
NACOV = nacov,
estimator = "DWLS",
parameterization = "delta",
se = "none",
test = "none"),
st = lavaan::cfa(model = st.mod,
sample.cov = cormat,
sample.nobs = nobs,
sample.mean = means,
sample.th = th,
WLS.V = wlsv,
NACOV = nacov,
estimator = "DWLS",
parameterization = "delta",
se = "none",
test = "none"),
times = 20)
rs.v.st
rs <- lavaan::cfa(model = rs.mod,
sample.cov = cormat,
sample.nobs = nobs,
sample.mean = means,
sample.th = th,
WLS.V = wlsv,
NACOV = nacov,
estimator = "DWLS",
parameterization = "delta",
se = "none",
test = "none")
## Do the matrix/sample stats and data method produce the same results
all.equal(lavaan::parameterestimates(matonly, se = FALSE, zstat = FALSE, pvalue = FALSE, ci = FALSE),
lavaan::parameterestimates(rs, se = FALSE, zstat = FALSE, pvalue = FALSE, ci = FALSE))
check <- dplyr::full_join(lavaan::parameterestimates(matonly, se = FALSE, zstat = FALSE, pvalue = FALSE, ci = FALSE),
lavaan::parameterestimates(dat, se = FALSE, zstat = FALSE, pvalue = FALSE, ci = FALSE),
by = c("lhs", "op", "rhs", "label"), suffix = c(".mat", ".dat"))
check <- dplyr::full_join(lavaan::parameterestimates(matonly, se = FALSE, zstat = FALSE, pvalue = FALSE, ci = FALSE),
lavaan::parameterestimates(rs, se = FALSE, zstat = FALSE, pvalue = FALSE, ci = FALSE),
by = c("lhs", "op", "rhs", "label"), suffix = c(".mat", ".rs"))
View(check)
## internal function for extracting standardized loadings
get_std_loadings <- function(object, type = "std.all"){
# extracting unrotated standardized results
params <- lavaan::standardizedsolution(object, type = type,
se = FALSE, zstat = FALSE, # Not needed so saves
pvalue = FALSE, ci = FALSE)# computation time
loaddf <- params[params$op == "=~",]
# loading matrix dimension names
inames <- unique(loaddf$rhs) # item names
fnames <- unique(loaddf$lhs) # factor names
# matrix of standardized factor loadings
loadmat <- matrix(loaddf$est.std,
ncol = length(fnames), nrow = length(inames),
byrow = FALSE, dimnames = list(inames, fnames))
return(loadmat)
}
all.equal(get_std_loadings(mat), get_std_loadings(rs)) # nope
all.equal(get_std_loadings(matonly), get_std_loadings(rs)) # nope
get_std_loadings(rs)
get_std_loadings(matonly)
lapply(list(matonly, rs),function(x) lavaan::lavInspect(x, "iterations"))
summary(rs, fit.measures = TRUE)
lavaan::summary(rs, fit.measures = TRUE)
?psych::fa
pfa <- psych::fa(r = cormat, nfactors = 3, n.obs = nobs, rotate = "none", covar = FALSE, fm = "wls")
pfa
