for(i in 1:length(inames)){
thresh <- max(maxload[[i]], threshold, na.rm = TRUE)
loadings.max[i, ][abs(loadings.max[i, ]) < thresh] <- NA
}
# returns vector with each element being the lavaan syntax identifying the factor
cfa.syntax <- c()
for(fn in 1:length(fnames)){
cfa.syntax <- c(cfa.syntax,
paste0(fnames[[fn]], " =~ ",
paste(inames[!is.na(loadings.max[,fn])],
collapse = " + ")))
}
# What to do with single item factors?
if(length(single.item) > 1){
single.item <- "keep"
}
if(single.item == "keep"){
# final cfa syntax
cfa.syntax <- paste(cfa.syntax, collapse = "\n")
} else if(single.item == "drop"){
# drops single item factors before collapsing to final syntax
cfa.syntax <- cfa.syntax[nchar(cfa.syntax) - nchar(gsub("+", "", cfa.syntax,
fixed = TRUE)) > 0]
cfa.syntax <- paste(cfa.syntax, collapse = "\n")
} else if(single.item == ""){
# check if they exist
if(all(nchar(cfa.syntax) - nchar(gsub("+", "", cfa.syntax,fixed = TRUE)) > 0) == TRUE){
cfa.syntax <- paste(cfa.syntax, collapse = "\n")
} else {
cfa.syntax <- ""
}
}
return(cfa.syntax)
}
## internal function for extracting standardized loadings
get_std_loadings <- function(object, type = "std.all"){
# extracting unrotated standardized results
params <- lavaan::standardizedsolution(object, type = type,
se = FALSE, zstat = FALSE, # Not needed so saves
pvalue = FALSE, ci = FALSE)# computation time
loaddf <- params[params$op == "=~",]
# loading matrix dimension names
inames <- unique(loaddf$rhs) # item names
fnames <- unique(loaddf$lhs) # factor names
# matrix of standardized factor loadings
loadmat <- matrix(loaddf$est.std,
ncol = length(fnames), nrow = length(inames),
byrow = FALSE, dimnames = list(inames, fnames))
return(loadmat)
}
get_std_loadings(st.dat)
get_std_loadings(st.mat)
st.mod <- lavaan::lavInspect(st.mat, "call")$model
st.mod
cat(st.mod)
mat = lavaan::lavaan(model = st.mod,
data = items,
sample.cov = cormat,
sample.nobs = nobs,
estimator = "DWLS",
se = "none")
dat = avaan::lavaan(model = st.mod,
data = items,
estimator = "DWLS",
se = "none")
dat = lavaan::lavaan(model = st.mod,
data = items,
estimator = "DWLS",
se = "none")
get_std_loadings(dat)
get_std_loadings(mat)
inputtype <- microbenchmark::microbenchmark(
mat = lavaan::lavaan(model = st.mod,
data = items,
sample.cov = cormat,
sample.nobs = nobs,
estimator = "DWLS",
se = "none"),
dat = lavaan::lavaan(model = st.mod,
data = items,
estimator = "DWLS",
se = "none"),
times = 20
)
pars <- lavaan::parameterestimates(dat, se = FALSE, zstat = FALSE, pvalue = FALSE, ci = FALSE)
View(pars)
View(inputtype)
inputtype
lavaan::lavInspect(dat, "est")
lavaan::lavInspect(st.mat, "est")
lavaan::lavInspect(st.dat, "est")
## call
lavaan::lavInspect(dat, "call")
?psych::fa
pfa <- psych::fa(r = cormat, nfactors = 3, n.obs = nobs,
rotate = "none", covar = FALSE, scores = FALSE,
fm = "wls")
pfa <- psych::fa(r = cormat, nfactors = 3, n.obs = nobs,
rotate = "none", covar = FALSE,
fm = "wls")
str(pfa)
pfa$loadings
?psych::print.psych
print(pfa$loadings)
View(pfa$loadings)
class(pfa$loadings)
pfa$Structure
class(pfa$Structure)
# same results
get_std_loadings(dat)
get_std_loadings(mat)
pfa$loadings
## call
lavaan::lavInspect(dat, "call")
lavaan::lavInspect(st.dat, "call")
lavaan::lavInspect(st.dat, c("categorical", "parameterization"))
lavaan::lavInspect(st.dat, "categorical")
lavaan::lavInspect(dat, "categorical")
lapply(list(dat, mat, st.dat, st.mat), function(x) lavaan::lavInspect(x, "parameterization"))
lapply(list(dat, mat, st.dat, st.mat), function(x) lavaan::lavInspect(x, "categorical"))
st.mat = semTools::efaUnrotate(data = items,
nf = 3,
start = FALSE,
sample.cov = cormat,
sample.nobs = nobs,
# WLS.V = wlsv,
# NACOV = nacov,
# estimator = "DWLS",
ordered = names(items),
parameterization = "delta",
se = "none")
st.mat = semTools::efaUnrotate(data = items,
nf = 3,
start = FALSE,
sample.cov = cormat,
sample.nobs = nobs,
# WLS.V = wlsv,
# NACOV = nacov,
# estimator = "DWLS",
ordered = names(items),
parameterization = "theta",
se = "none")
st.dat = semTools::efaUnrotate(data = items,
nf = 3,
start = FALSE,
ordered = names(items),
# estimator = "DWLS",
# missing = "pairwise",
parameterization = "theta",
se = "none")
# Produce different results
get_std_loadings(st.mat)
get_std_loadings(st.dat)
mat = lavaan::lavaan(model = st.mod,
data = items,
sample.cov = cormat,
sample.nobs = nobs,
ordered = names(items),
# estimator = "DWLS",
se = "none")
dat = lavaan::lavaan(model = st.mod,
data = items,
ordered = names(items),
# estimator = "DWLS",
se = "none")
# same results
get_std_loadings(mat)
get_std_loadings(dat)
## semTools with previously calculated polychoric correlation matrix
st.mat = semTools::efaUnrotate(data = items,
nf = 3,
start = FALSE,
sample.cov = cormat,
sample.nobs = nobs,
# WLS.V = wlsv,
# NACOV = nacov,
# estimator = "DWLS",
ordered = names(items),
parameterization = "theta",
se = "none")
## semTools with only raw data input
st.dat = semTools::efaUnrotate(data = items,
nf = 3,
start = FALSE,
# estimator = "DWLS",
# missing = "pairwise",
ordered = names(items),
parameterization = "theta",
se = "none")
## direct with polychoric correlation
lv.mat <- lavaan::lavaan(model = st.mod,
data = items,
sample.cov = cormat,
sample.nobs = nobs,
# estimator = "DWLS",
ordered = names(items),
se = "none")
## direct with only raw data input
lv.dat <- lavaan::lavaan(model = st.mod,
data = items,
# estimator = "DWLS",
ordered = names(items),
se = "none")
lapply(list(st.mat, st.dat, lv.mat, lv.dat), function(x) lavaan::lavInspect(x, "categorical"))
lapply(list(st.mat, st.dat, lv.mat, lv.dat), function(x) lavaan::lavInspect(x, "parameterization"))
# same results
get_std_loadings(st.mat)
get_std_loadings(st.dat)
get_std_loadings(lv.mat)
get_std_loadings(lv.dat)
lavaan::parTable(lv.mat)
View(lavaan::parTable(lv.mat))
lapply(list(st.mat, st.dat, lv.mat, lv.dat), function(x) lavaan::lavInspect(x, "est"))
## direct with polychoric correlation
lv.mat <- lavaan::lavaan(model = st.mod,
data = items,
sample.cov = cormat,
sample.nobs = nobs,
# estimator = "DWLS",
ordered = names(items),
parameterization = "theta",
se = "none")
## direct with only raw data input
lv.dat <- lavaan::lavaan(model = st.mod,
data = items,
# estimator = "DWLS",
ordered = names(items),
parameterization = "theta",
se = "none")
lapply(list(st.mat, st.dat, lv.mat, lv.dat), function(x) lavaan::lavInspect(x, "categorical"))
lapply(list(st.mat, st.dat, lv.mat, lv.dat), function(x) lavaan::lavInspect(x, "parameterization"))
lapply(list(st.mat, st.dat, lv.mat, lv.dat), function(x) lavaan::lavInspect(x, "iterations"))
lapply(list(st.mat, st.dat, lv.mat, lv.dat), function(x) lavaan::lavInspect(x, "options"))
lapply(list(st.mat, st.dat, lv.mat, lv.dat), function(x) lavaan::lavInspect(x, "options")$missing)
lapply(list(st.mat, st.dat, lv.mat, lv.dat), function(x) lavaan::lavInspect(x, "est"))
## direct with polychoric correlation
lv.mat <- lavaan::lavaan(model = st.mod,
data = items,
sample.cov = cormat,
sample.nobs = nobs,
# estimator = "DWLS",
ordered = names(items),
parameterization = "theta",
se = "none")
## direct with only raw data input
lv.dat <- lavaan::lavaan(model = st.mod,
data = items,
# estimator = "DWLS",
ordered = names(items),
parameterization = "theta",
se = "none")
# same results
get_std_loadings(st.mat)
get_std_loadings(st.dat)
get_std_loadings(lv.mat)
get_std_loadings(lv.dat)
all.equal(lavaan::lavInspect(lv.mat, "options"), lavaan::lavInspect(lv.dat, "options"))
all.equal(lavaan::lavInspect(lv.mat, "options"), lavaan::lavInspect(st.mat, "options"))
## direct with polychoric correlation
lv.mat <- lavaan::cfa(model = st.mod,
data = items,
sample.cov = cormat,
sample.nobs = nobs,
# estimator = "DWLS",
ordered = names(items),
parameterization = "theta",
se = "none")
## direct with only raw data input
lv.dat <- lavaan::cfa(model = st.mod,
data = items,
# estimator = "DWLS",
ordered = names(items),
parameterization = "theta",
se = "none")
# same results
get_std_loadings(st.mat)
get_std_loadings(st.dat)
get_std_loadings(lv.mat)
get_std_loadings(lv.dat)
lapply(list(st.mat, st.dat, lv.mat, lv.dat), function(x) lavaan::lavInspect(x, "categorical"))
lapply(list(st.mat, st.dat, lv.mat, lv.dat), function(x) lavaan::lavInspect(x, "parameterization"))
lapply(list(st.mat, st.dat, lv.mat, lv.dat), function(x) lavaan::lavInspect(x, "iterations"))
lapply(list(st.mat, st.dat, lv.mat, lv.dat), function(x) lavaan::lavInspect(x, "options")$missing)
lapply(list(st.mat, st.dat, lv.mat, lv.dat), function(x) lavaan::lavInspect(x, "est"))
all.equal(lavaan::lavInspect(lv.mat, "options"), lavaan::lavInspect(lv.dat, "options"))
all.equal(lavaan::lavInspect(lv.mat, "options"), lavaan::lavInspect(st.mat, "options"))
## direct with only raw data input
lv.dat <- lavaan::cfa(model = st.mod,
data = items,
# estimator = "DWLS",
ordered = names(items),
parameterization = "delta",
se = "none")
## direct with polychoric correlation
lv.mat <- lavaan::cfa(model = st.mod,
data = items,
sample.cov = cormat,
sample.nobs = nobs,
# estimator = "DWLS",
ordered = names(items),
parameterization = "delta",
se = "none")
get_std_loadings(st.dat)
get_std_loadings(lv.mat)
lapply(list(st.mat, st.dat, lv.mat, lv.dat), function(x) lavaan::lavInspect(x, "categorical"))
lapply(list(st.mat, st.dat, lv.mat, lv.dat), function(x) lavaan::lavInspect(x, "parameterization"))
lapply(list(st.mat, st.dat, lv.mat, lv.dat), function(x) lavaan::lavInspect(x, "iterations"))
lapply(list(st.mat, st.dat, lv.mat, lv.dat), function(x) lavaan::lavInspect(x, "options")$missing)
lapply(list(st.mat, st.dat, lv.mat, lv.dat), function(x) lavaan::lavInspect(x, "est"))
all.equal(lavaan::lavInspect(lv.mat, "options"), lavaan::lavInspect(lv.dat, "options"))
all.equal(lavaan::lavInspect(lv.mat, "options"), lavaan::lavInspect(st.mat, "options"))
# Threshold estimates
all.equal(lavaan::lavInspect(lv.mat, "est")$tau, lavaan::lavInspect(lv.dat, "est")$tau)
all.equal(lavaan::lavInspect(lv.mat, "est")$tau, lavaan::lavInspect(st.mat, "est")$tau)
## direct with polychoric correlation
lv.mat <- lavaan::cfa(model = st.mod,
data = items,
sample.cov = cormat,
sample.nobs = nobs,
# estimator = "DWLS",
ordered = names(items),
parameterization = "theta",
se = "none")
## direct with only raw data input
lv.dat <- lavaan::cfa(model = st.mod,
data = items,
# estimator = "DWLS",
ordered = names(items),
parameterization = "theta",
se = "none")
all.equal(lavaan::lavInspect(lv.mat, "est")$tau, lavaan::lavInspect(st.mat, "est")$tau) # no
lavaan::lavInspect(lv.dat, "options")$estimator
lavaan::lavInspect(prelim, "sampstat")
th <- lavaan::lavInspect(prelim, "sampstat")$th
## Common correlation matrix
prelim <- lavaan::lavCor(items,
ordered = names(items),
missing = "listwise",
output = "fit",
cor.smooth = FALSE) # could include a cluster =  argument
nobs <- lavaan::lavInspect(prelim, "nobs")
## Common correlation matrix
prelim <- lavaan::lavCor(items,
ordered = names(items),
missing = "pairwise",
output = "fit",
cor.smooth = FALSE) # could include a cluster =  argument
nobs <- lavaan::lavInspect(prelim, "nobs")
wlsv <- lavaan::lavInspect(prelim, "wls.v")
lavaan::lavInspect(prelim, "options")$estimator
cormat
nacov <- lavaan::lavInspect(prelim, "gamma")
cormat <- lavaan::lavInspect(prelim, "cor.ov") # same as lavaan::lavInspect(prelim, "sampstat")$cov
## Common correlation matrix
prelim <- lavaan::lavCor(items,
ordered = names(items),
# estimator = "DWLS",
missing = "pairwise",
output = "fit",
cor.smooth = FALSE) # could include a cluster =  argument
nobs <- lavaan::lavInspect(prelim, "nobs")
wlsv <- lavaan::lavInspect(prelim, "wls.v")
lavaan::lavInspect(prelim, "options")$estimator
## Common correlation matrix
prelim <- lavaan::lavCor(object = items,
ordered = names(items),
estimator = "DWLS",  # must specify estimator, otherwise defaults to none
missing = "pairwise",
output = "fit",
cor.smooth = FALSE) # could include a cluster =  argument
nobs <- lavaan::lavInspect(prelim, "nobs")
wlsv <- lavaan::lavInspect(prelim, "wls.v")
nacov <- lavaan::lavInspect(prelim, "gamma")
cormat <- lavaan::lavInspect(prelim, "cor.ov") # same as lavaan::lavInspect(prelim, "sampstat")$cov
itrtns <- lavaan::lavInspect(prelim, "iterations")
th <- lavaan::lavInspect(prelim, "sampstat")$th
lavaan::lavInspect(prelim, "options")$estimator
## direct with polychoric correlation
lv.mat <- lavaan::cfa(model = st.mod,
data = items,
sample.cov = cormat,
sample.nobs = nobs,
# sample.th = ,
# estimator = "DWLS",
ordered = names(items),
parameterization = "theta",
se = "none")
## direct with only raw data input
lv.dat <- lavaan::cfa(model = st.mod,
data = items,
# estimator = "DWLS",
ordered = names(items),
parameterization = "theta",
se = "none")
all.equal(lavaan::lavInspect(prelim, "est")$tau, th) # yes
th
lavaan::lavInspect(prelim, "est")$tau
class(lavaan::lavInspect(prelim, "est")$tau)
class(th)
View(wlsv)
View(wlsv)
th
cortmat
cormat
all.equal(lavaan::lavInspect(lv.mat, "sampstat")$th, th) # yes
lapply(list(st.mat, st.dat, lv.mat, lv.dat), function(x) lavaan::lavInspect(x, "categorical"))
lapply(list(st.mat, st.dat, lv.mat, lv.dat), function(x) lavaan::lavInspect(x, "options")$missing)
lapply(list(st.mat, st.dat, lv.mat, lv.dat), function(x) lavaan::lavInspect(x, "nobs"))
## mat is slightly faster;
inputtype <- microbenchmark::microbenchmark(
mat = lavaan::cfa(model = st.mod,
data = items,
sample.cov = cormat,
sample.nobs = nobs,
# sample.th = ,
# estimator = "DWLS",
ordered = names(items),
parameterization = "delta",
se = "none"),
dat = lavaan::cfa(model = st.mod,
data = items,
# estimator = "DWLS",
ordered = names(items),
parameterization = "delta",
se = "none"),
times = 20
)
inputtype
matonly <- lavaan::cfa(model = st.mod,
sample.cov = cormat,
sample.nobs = nobs,
sample.th = th,
WLS.V = wlsv,
NACOV = nacov,
estimator = "DWLS",
parameterization = "delta",
se = "none")
tau <- lavaan::lavInspect(prelim, "est")$tau
matonly <- lavaan::cfa(model = st.mod,
sample.cov = cormat,
sample.nobs = nobs,
sample.th = tau,
WLS.V = wlsv,
NACOV = nacov,
estimator = "DWLS",
parameterization = "delta",
se = "none")
matonly <- lavaan::cfa(model = st.mod,
sample.cov = cormat,
sample.nobs = nobs,
WLS.V = wlsv,
NACOV = nacov,
estimator = "DWLS",
parameterization = "delta",
se = "none")
warnings()
lavaan::summary(matonly)
rs.mod <- regsem::efaModel(3, names(items))
rs <- lavaan::cfa(model = rs.mod,
data = items,
ordered = names(items),
parameterization = "theta",
se = "none")
rs <- lavaan::cfa(model = rs.mod,
data = items,
ordered = names(items),
parameterization = "theta",
se = "none",
test = "none")
#### Comparing time difference when cor matrix is provided or not ####
## mat is slightly faster; mean = 11.8 vs. 12.1
# not sure if the correlation matrix is actually used or recalculated
inputtype <- microbenchmark::microbenchmark(
mat = lavaan::cfa(model = st.mod,
data = items,
sample.cov = cormat,
sample.nobs = nobs,
# estimator = "DWLS",
ordered = names(items),
parameterization = "delta",
se = "none",
test = "none"),
dat = lavaan::cfa(model = st.mod,
data = items,
# estimator = "DWLS",
ordered = names(items),
parameterization = "delta",
se = "none",
test = "none"),
times = 20
)
inputtype
rs.v.st <- microbenchmark::microbenchmark(
rs = lavaan::cfa(model = rs.mod,
data = items,
ordered = names(items),
parameterization = "delta",
se = "none",
test = "none"),
st <- lavaan::cfa(model = st.mod,
data = items,
ordered = names(items),
parameterization = "delta",
se = "none",
test = "none"),
times = 20)
rs.v.st
cat(st.mod)
all.equal(get_std_loadings(lv.dat), get_std_loadings(rs))
lapply(list(lv.dat, rs),function(x) lavaan::lavInspect(x, "iterations"))
get_std_loadings(rs)
get_std_loadings(lv.dat)
